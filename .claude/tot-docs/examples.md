# ToT 使用示例

本文档提供 3 个完整的 ToT 系统使用示例，展示从问题输入到最终输出的完整过程。

---

## 示例 1: 数学推理 - 游戏24

### 用户输入
```
/tot 用 4、9、10、13 得到 24
```

### 执行过程

#### 阶段1: Orchestrator 分析
```
任务类型: math_reasoning
选择策略: BFS（广度优先搜索）
配置:
  - 分支因子: 5
  - 最大深度: 3
  - 剪枝阈值: 5.0
```

#### 阶段2: Decomposer 分解
```json
{
  "thought_granularity": "single_equation",
  "intermediate_steps": [
    "选择两个数字进行第一次运算",
    "用结果与第三个数字运算",
    "用结果与最后一个数字运算，检查是否等于24"
  ],
  "depth_estimate": 3,
  "constraints": [
    "必须使用所有数字各一次",
    "只能使用 + - × ÷ 四种运算"
  ],
  "success_criteria": "最终计算结果精确等于 24"
}
```

#### 阶段3: Explorer 搜索

**深度 0 → 1**:
```
扩展 root 节点 "初始: 4, 9, 10, 13"

Generator 生成 5 个候选:
1. "13 - 9 = 4, 剩余: 4, 4, 10"
2. "10 + 4 = 14, 剩余: 9, 13, 14"
3. "13 × 4 = 52, 剩余: 9, 10, 52"
4. "10 - 4 = 6, 剩余: 6, 9, 13"
5. "9 + 4 = 13, 剩余: 10, 13, 13"

Evaluator 评分:
1. 7.5分 - "产生了4（24的因子），剩余数字可组合成24"
2. 6.0分 - "14接近24的一半，但组合困难"
3. 3.0分 - "52太大，难回到24" [剪枝]
4. 7.0分 - "6是24的因子，有希望"
5. 5.0分 - "两个13较难处理"

选择 top-3: node_1 (7.5), node_4 (7.0), node_2 (6.0)
```

**深度 1 → 2**:
```
扩展 node_1 "13-9=4, 剩余: 4,4,10"

Generator 生成候选:
- "4 + 4 = 8, 剩余: 8, 10"  → 5.0分
- "4 × 4 = 16, 剩余: 10, 16" → 6.0分
- "10 - 4 = 6, 剩余: 4, 6"   → 8.0分 ★
- "10 + 4 = 14, 剩余: 4, 14" → 5.5分
- "10 ÷ 4 = 2.5, 剩余: 4, 2.5" → 3.0分 [剪枝]

最优: node_1_3 "10-4=6, 剩余: 4,6" (8.0分)

（同时扩展 node_4 和 node_2...）
```

**深度 2 → 3**:
```
扩展 node_1_3 "10-4=6, 剩余: 4,6"

Generator 生成候选:
- "4 + 6 = 10" → 4.0分
- "6 - 4 = 2"  → 3.0分
- "6 × 4 = 24" → 10.0分 ✓✓✓ 找到解！

Evaluator: "6×4=24 精确达成目标，完美解决方案"

终止搜索，找到最佳路径:
[root → node_1 → node_1_3 → node_1_3_3]
```

#### 阶段4: Synthesizer 合成

```json
{
  "answer": "(10 - (13 - 9)) × 4 = 24",
  "reasoning_trace": [
    "步骤1: 计算 13 - 9 = 4（产生24的因子）",
    "步骤2: 计算 10 - 4 = 6（6也是24的因子）",
    "步骤3: 计算 6 × 4 = 24 ✓（达成目标）"
  ],
  "confidence": 1.0,
  "verification": {
    "is_valid": true,
    "check": "(10 - (13 - 9)) × 4 = (10 - 4) × 4 = 6 × 4 = 24 ✓"
  }
}
```

### 最终输出

```
## 最终答案
(10 - (13 - 9)) × 4 = 24

## 推理过程
1. 步骤1: 计算 13 - 9 = 4（产生24的因子）
2. 步骤2: 计算 10 - 4 = 6（6也是24的因子）
3. 步骤3: 计算 6 × 4 = 24 ✓（达成目标）

## 验证
(10 - (13 - 9)) × 4 = (10 - 4) × 4 = 6 × 4 = 24 ✓

## 搜索统计
- 探索节点数: 18
- 搜索深度: 3
- 搜索策略: BFS
- LLM 调用次数: 12（生成器 6 次 + 评估器 6 次）
```

---

## 示例 2: 创意写作

### 用户输入
```
/tot 写一个连贯的段落，必须以这4个句子结尾："她笑了。雨停了。门开了。他走了。"
```

### 执行过程

#### 阶段1: Orchestrator 分析
```
任务类型: creative_writing
选择策略: BFS
配置:
  - 分支因子: 4
  - 最大深度: 2（计划 + 执行）
  - 剪枝阈值: 6.0
```

#### 阶段2: Decomposer 分解
```json
{
  "thought_granularity": "paragraph_plan",
  "intermediate_steps": [
    "构思整体叙事框架：如何自然连接4个结尾句",
    "执行：编写完整段落，确保结尾句的连贯性"
  ],
  "depth_estimate": 2,
  "constraints": [
    "必须包含所有4个指定结尾句",
    "段落需连贯，不能生硬拼接",
    "长度适中（300-500字）"
  ],
  "success_criteria": "段落连贯、4个结尾句自然融入、具有创意"
}
```

#### 阶段3: Explorer 搜索

**深度 0 → 1（计划阶段）**:
```
Generator 生成 4 个叙事方向:

1. "戏剧冲突开篇：主角在暴风雨中收到神秘包裹"
   → Evaluator: 8.5分
   "暴风雨为'雨停了'埋下伏笔，神秘包裹可引出'门开了'和后续人物"

2. "环境描写切入：用细腻的雨景描写营造氛围"
   → Evaluator: 6.5分
   "氛围好但缺乏冲突，难以引出'门开了'和'他走了'"

3. "对话开篇：两个角色在争吵"
   → Evaluator: 7.0分
   "直接进入冲突，吸引力强，但未涉及'雨'，后续略显生硬"

4. "回忆场景：主角独自回忆与某人的往事"
   → Evaluator: 7.5分
   "情感铺垫充分，可自然引出人物出现和离开"

选择 top-3: 方向1 (8.5), 方向4 (7.5), 方向3 (7.0)
```

**深度 1 → 2（执行阶段）**:
```
基于方向1 "戏剧冲突开篇" 生成完整段落:

Generator 输出（经过多次迭代优化）:
"暴风雨中，她独自坐在窗前，忽然门铃响起。打开门，是一个湿透的快递员，递来一个破旧的纸箱。她颤抖着打开，里面是一封泛黄的信和一张褪色的照片——那是三年前失踪的他留下的。信上写着：'对不起让你等了这么久，我回来了。'泪水模糊了视线，她笑了。窗外，雨停了。楼下传来熟悉的脚步声，门开了。是他，真的是他。他们拥抱良久，直到他轻声说'我该走了，还有最后一件事要完成。'他走了，但这次她知道，他会回来。"

Evaluator: 9.0分
- 连贯性: 9/10（情节自然流畅）
- 创意性: 8/10（悬念+情感张力）
- 约束满足: 10/10（4个句子自然融入）
```

#### 阶段4: Synthesizer 合成

```json
{
  "answer": "暴风雨中，她独自坐在窗前，忽然门铃响起...[完整段落]",
  "reasoning_trace": [
    "开篇策略: 选择戏剧冲突（暴风雨+神秘包裹）制造悬念",
    "发展: 揭示包裹来自失踪恋人，引发情感张力",
    "高潮: 恋人重现，满足读者期待",
    "结尾: 自然融入四个约束句，'他走了'增加开放性结局"
  ],
  "confidence": 0.85,
  "verification": {
    "is_valid": true,
    "constraints_check": [
      "'她笑了' ✓ (出现在段落中)",
      "'雨停了' ✓ (自然衔接暴风雨开篇)",
      "'门开了' ✓ (情节必需，恋人出现)",
      "'他走了' ✓ (开放式结局)"
    ]
  }
}
```

### 最终输出

```
## 最终作品

暴风雨中，她独自坐在窗前，忽然门铃响起。打开门，是一个湿透的快递员，递来一个破旧的纸箱。她颤抖着打开，里面是一封泛黄的信和一张褪色的照片——那是三年前失踪的他留下的。信上写着：'对不起让你等了这么久，我回来了。'泪水模糊了视线，她笑了。窗外，雨停了。楼下传来熟悉的脚步声，门开了。是他，真的是他。他们拥抱良久，直到他轻声说'我该走了，还有最后一件事要完成。'他走了，但这次她知道，他会回来。

## 创作思路
1. 开篇：戏剧冲突（暴风雨+神秘包裹）制造悬念
2. 发展：包裹来自失踪恋人，情感张力
3. 高潮：恋人重现，满足读者期待
4. 结尾：四个约束句自然融入，开放式结局

## 约束检查
✓ "她笑了" - 收到信后的情感释放
✓ "雨停了" - 与暴风雨开篇呼应
✓ "门开了" - 恋人出现的情节必需
✓ "他走了" - 开放式结尾，留有悬念

## 搜索统计
- 探索方向数: 4
- 最终选择: 戏剧冲突开篇（评分 8.5/10）
- 迭代次数: 2（优化段落衔接）
```

---

## 示例 3: 架构设计 - 小程序状态管理

### 用户输入
```
/tot 小程序应该用什么状态管理方案？项目需要全局状态共享、性能优化，团队3人，开发周期6周
```

### 执行过程

#### 阶段1: Orchestrator 分析
```
任务类型: architecture_design
选择策略: BFS
配置:
  - 分支因子: 4
  - 最大深度: 2（枚举方案 + 深入评估）
  - 剪枝阈值: 6.5
```

#### 阶段2: Decomposer 分解
```json
{
  "thought_granularity": "component_choice",
  "intermediate_steps": [
    "识别状态管理需求（全局共享、性能、学习成本）",
    "枚举候选方案（MobX、Redux、原生、其他）",
    "深入评估最优方案的实施细节"
  ],
  "depth_estimate": 2,
  "constraints": [
    "必须兼容微信小程序环境",
    "团队3人需快速上手",
    "6周周期不允许长时间学习",
    "包体积限制（<100KB）"
  ],
  "success_criteria": "方案满足性能、可维护性、团队能力、有充分技术论证"
}
```

#### 阶段3: Explorer 搜索

**深度 0 → 1（枚举方案）**:
```
Generator 生成 4 个候选方案:

1. MobX
   "响应式状态管理，学习成本低，适合中小型项目"
   Metadata: {
     bundle_size: "30KB",
     learning_curve: "low",
     performance: "excellent"
   }
   → Evaluator: 8.5分

2. Redux + Redux-Toolkit
   "成熟稳定，可预测性强，适合大型项目和团队协作"
   Metadata: {
     bundle_size: "45KB",
     learning_curve: "medium",
     performance: "good"
   }
   → Evaluator: 7.0分

3. 原生 setData + globalData
   "零依赖，简单直接，适合状态逻辑简单的场景"
   Metadata: {
     bundle_size: "0KB",
     learning_curve: "none",
     performance: "poor (frequent setData)"
   }
   → Evaluator: 5.5分（性能不满足需求）[接近剪枝阈值]

4. Vuex（如果使用 mpvue/uni-app）
   "Vue 生态方案，需要框架支持"
   → Evaluator: 6.0分（题设未提及使用 Vue 框架，适配成本高）

选择 top-2 深入评估: MobX (8.5), Redux (7.0)
```

**深度 1 → 2（深入评估）**:
```
深入评估 MobX:

Generator 生成实施方案:
"""
MobX 实施方案:

技术选型:
- mobx-miniprogram: 4.x 版本
- mobx-miniprogram-bindings: 绑定助手

优点:
1. 响应式特性：自动追踪依赖，性能优于手动 setData
2. 学习成本低：API 简洁（observable, action, computed）
3. Bundle 小：~30KB，符合小程序限制
4. 适合场景：中小型项目，状态逻辑不太复杂

缺点:
1. 生态不如 Redux 成熟
2. 调试相对困难（响应式追踪复杂度）
3. 对非常大的项目（>100页面）可能架构不足

实施步骤:
1. 安装依赖: npm install mobx-miniprogram mobx-miniprogram-bindings
2. 创建 Store: store/user.js, store/cart.js
3. 页面绑定: 使用 storeBindingsBehavior
4. 性能优化: 避免在 store 中存储大对象

团队匹配度:
- 3人团队可在1周内掌握（API少）
- 6周周期充足，2周开发 store 架构 + 4周业务开发

风险评估:
- 低风险：技术成熟，社区活跃
- 中风险：团队首次使用响应式框架（可通过1天培训缓解）
"""

Evaluator: 9.0分
- 适用性: 9/10（完美匹配需求）
- 可行性: 9/10（实施路径清晰）
- 风险: 8/10（风险可控）
```

#### 阶段4: Synthesizer 合成

```json
{
  "answer": "推荐使用 MobX 作为状态管理方案",
  "reasoning_trace": [
    "需求分析: 全局状态共享（用户信息、购物车等）+ 性能优化（避免频繁 setData）+ 快速上手",
    "方案对比: 评估了 MobX、Redux、原生 setData、Vuex 四种方案",
    "选择 MobX 的核心理由:",
    "  1. 响应式特性自动追踪依赖，性能优于手动 setData",
    "  2. 学习成本低（API 仅 observable/action/computed），3人团队1周可掌握",
    "  3. Bundle size 30KB，远低于包体积限制",
    "  4. 适合中小型项目，与6周开发周期匹配",
    "Trade-offs:",
    "  优点: 开发效率高、代码量少、性能好、易维护",
    "  缺点: 生态不如 Redux（但对本项目影响有限）、调试稍复杂",
    "实施路径: 第1-2周搭建 store 架构 → 第3-6周业务开发"
  ],
  "confidence": 0.9,
  "verification": {
    "is_valid": true,
    "requirements_check": [
      "✓ 全局状态共享：MobX store 支持跨页面共享",
      "✓ 性能优化：响应式更新，避免全量 setData",
      "✓ 快速上手：API 简洁，1周培训期",
      "✓ 包体积：30KB < 100KB 限制",
      "✓ 6周周期：实施路径清晰可行"
    ]
  },
  "alternative_solutions": [
    "Redux + Redux-Toolkit: 如果团队已有 Redux 经验且项目规模大（>50页面）",
    "原生 globalData + EventBus: 如果状态极简单（仅2-3个全局变量）"
  ]
}
```

### 最终输出

```
## 推荐方案
**MobX**

## 核心理由
1. **性能优化**：响应式特性自动追踪依赖，性能优于手动 setData
2. **快速上手**：API 简洁（observable/action/computed），3人团队1周可掌握
3. **包体积**：30KB，符合小程序限制
4. **项目匹配**：适合中小型项目，与6周开发周期完美匹配

## 方案对比

| 方案 | 评分 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|---------|
| **MobX** | 8.5/10 | 简单、高效、性能好 | 生态较小 | ✓ 当前项目 |
| Redux | 7.0/10 | 生态成熟、可预测 | 模板代码多、学习曲线陡 | 大型项目、已有经验 |
| 原生 setData | 5.5/10 | 零依赖 | 性能差、难维护 | 极简单状态 |
| Vuex | 6.0/10 | Vue生态 | 需框架支持 | 使用Vue框架时 |

## 实施计划

### 第1-2周：架构搭建
```bash
# 安装依赖
npm install mobx-miniprogram mobx-miniprogram-bindings

# 创建 Store
store/
├── user.js      # 用户信息
├── cart.js      # 购物车
└── common.js    # 全局配置
```

### 第3-6周：业务开发
- 页面绑定 Store：使用 `storeBindingsBehavior`
- 性能优化：避免在 store 中存储大对象（>1MB）

### 团队培训（1天）
- MobX 核心概念
- 小程序集成方法
- 最佳实践和常见陷阱

## Trade-offs
**优点**：
- ✓ 开发效率高（代码量减少约40%）
- ✓ 性能好（自动批量更新）
- ✓ 易维护（响应式逻辑清晰）

**缺点**：
- ⚠ 生态不如 Redux 成熟（但对本项目影响有限）
- ⚠ 调试稍复杂（响应式追踪需理解）

## 风险评估
- **技术风险**：低（技术成熟，GitHub 3.2k stars）
- **学习风险**：低（1周培训 + 1周实践）
- **维护风险**：低（代码简洁，易交接）

## 替代方案
1. **Redux + Redux-Toolkit**：如果团队已有 Redux 经验且项目规模大（>50页面）
2. **原生 globalData**：如果状态极简单（仅2-3个全局变量）

## 搜索统计
- 评估方案数: 4
- 最优方案: MobX (8.5/10)
- 次优方案: Redux (7.0/10)
- 决策深度: 2层（枚举 → 深入评估）
```

---

## 总结

这三个示例展示了 ToT 系统在不同类型任务中的应用：

1. **数学推理**：系统搜索，多路径探索，找到最优解
2. **创意写作**：平衡创意和约束，生成连贯且满足要求的内容
3. **架构设计**：全面评估，权衡利弊，给出有充分论证的建议

ToT 的核心优势：
- ✅ **系统性**：不放过任何有希望的路径
- ✅ **透明性**：完整的推理过程可追溯
- ✅ **鲁棒性**：自动剪枝和回溯，避免死胡同
- ✅ **可配置**：根据任务类型自动调整策略

适合解决需要**深度思考**和**多方案比较**的复杂问题。
