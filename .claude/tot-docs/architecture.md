# ToT (Tree of Thoughts) 架构设计

基于论文 [Tree of Thoughts: Deliberate Problem Solving with Large Language Models](https://arxiv.org/html/2305.10601v2)

---

## 核心思想

ToT 将问题求解转化为**树搜索**任务：
- **节点** = 部分解决方案（中间推理状态）
- **边** = 推理步骤（从一个思维到下一个思维）
- **搜索** = 系统探索多条推理路径
- **评估** = 判断哪些路径更有前景
- **回溯** = 放弃无望分支，尝试其他方向

---

## 架构总览

```
用户问题
    ↓
┌─────────────────────────────────────────┐
│         Orchestrator（协调器）            │
│    - 接收问题                             │
│    - 分析任务类型                          │
│    - 选择搜索策略                          │
│    - 协调各 Agent                         │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│        Decomposer（分解器）               │
│    - 定义思维粒度                          │
│    - 分解中间步骤                          │
│    - 设定成功标准                          │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│         Explorer（探索器）                │
│    核心搜索引擎，管理思维树                  │
│                                          │
│    循环执行：                              │
│    ┌──────────────────────────┐         │
│    │ 1. 选择待扩展节点          │         │
│    │ 2. 调用 Generator 生成候选 │         │
│    │ 3. 调用 Evaluator 评估    │         │
│    │ 4. 更新树结构              │         │
│    │ 5. 决定：继续/剪枝/回溯     │         │
│    └──────────────────────────┘         │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│        Synthesizer（合成器）              │
│    - 提取最佳路径                          │
│    - 生成最终答案                          │
│    - 验证正确性                           │
└─────────────────────────────────────────┘
    ↓
返回用户
```

---

## Agent 角色详解

### 1. Orchestrator（协调器）
**角色定位**：项目经理

**职责**：
- 接收用户问题，识别任务类型（数学/创意/规划等）
- 根据任务特性选择搜索策略（BFS/DFS）
- 设置超参数（分支因子、最大深度、剪枝阈值）
- 按顺序调用各 Agent
- 汇总最终结果

**关键决策**：
- 任务类型 → 影响思维粒度和评估标准
- 搜索策略 → BFS适合浅层任务，DFS适合深层任务
- 分支因子 → 平衡探索广度和计算成本

---

### 2. Decomposer（分解器）
**角色定位**：系统分析师

**职责**：
- 分析问题结构，定义"思维单元"的粒度
- 为不同任务类型设计分解策略
- 预估搜索深度

**任务类型映射**：
| 任务 | 思维粒度 | 示例 |
|-----|---------|-----|
| 游戏24 | 单个方程式 | "13 - 9 = 4" |
| 创意写作 | 段落计划 | "用戏剧冲突开篇" |
| 架构设计 | 组件选择 | "使用MobX做状态管理" |
| 调试 | 假设验证 | "可能是越界错误" |

**输出示例**：
```
思维粒度: "single_equation"
步骤:
  1. 选择两个数字进行运算
  2. 用结果与第三个数字运算
  3. 得到目标数字
深度预估: 3
约束: ["必须用所有数字", "只能用+-×÷"]
```

---

### 3. Generator（生成器）
**角色定位**：创意团队

**职责**：
- 为当前节点生成 k 个候选思维
- 根据任务选择生成策略
- 确保候选多样性

**两种策略**：

#### 独立采样（Independent Sampling）
- 适用：开放性任务（创意写作）
- 方法：每个候选独立生成
- 优点：多样性高
- 成本：k 次 LLM 调用

#### 序列提议（Sequential Proposal）
- 适用：约束性任务（数学推理）
- 方法：一次性生成多个候选
- 优点：成本低，候选间有对比
- 成本：1 次 LLM 调用

**示例输出**（游戏24）：
```json
[
  {"id": "cand_1", "content": "13 - 9 = 4", "type": "subtraction"},
  {"id": "cand_2", "content": "10 + 4 = 14", "type": "addition"},
  {"id": "cand_3", "content": "13 × 4 = 52", "type": "multiplication"}
]
```

---

### 4. Evaluator（评估器）
**角色定位**：质量审核员

**职责**：
- 评估每个候选思维的"前景"
- 打分（0-10分）并说明理由
- 识别无望分支（触发剪枝）

**评估维度**：
- **正确性**：是否违反约束？
- **进展性**：距离目标还有多远？
- **可行性**：剩余步骤能完成吗？
- **创造性**（创意任务）：是否新颖有趣？

**示例评估**（游戏24）：
```json
{
  "node_id": "node_1_1",
  "score": 7.5,
  "confidence": 0.8,
  "reasoning": "产生了4，且剩余数字 4,4,10 可能组合成24（如 4×4+10-2，但没有2...需继续探索）",
  "dimension_scores": {
    "correctness": 10,  // 运算正确
    "progress": 5       // 中等进展
  }
}
```

---

### 5. Explorer（探索器）
**角色定位**：搜索引擎核心

**职责**：
- 维护思维树数据结构
- 执行搜索算法（BFS/DFS）
- 管理待扩展节点队列/栈
- 根据评分决定剪枝和回溯
- 追踪最佳路径

**BFS 算法**：
```
1. 初始化: frontier = [root]
2. 当 frontier 非空 且 未达到 max_depth:
   a. 弹出所有当前层节点
   b. 对每个节点:
      - 调用 Generator 生成 k 个候选
      - 调用 Evaluator 评分
      - 选择 top-b（分支因子）加入下一层
   c. frontier = 下一层的 top-b 节点
3. 返回评分最高路径
```

**DFS 算法**：
```
1. 从 root 开始
2. 当前节点未达到 max_depth:
   a. 调用 Generator 生成 1 个候选
   b. 调用 Evaluator 评分
   c. 如果 score < threshold:
      - 剪枝，回溯到父节点
      - 尝试生成不同候选
   d. 否则，继续深入该候选
3. 到达 max_depth 或无法继续，返回路径
```

---

### 6. Synthesizer（合成器）
**角色定位**：技术文档编写者

**职责**：
- 从 Explorer 返回的最佳路径提取答案
- 整合中间步骤，生成连贯的推理过程
- 验证答案正确性（如果可验证）
- 格式化输出

**示例输出**（游戏24）：
```
最终答案: (10 - (13 - 9)) × 4 = 24

推理过程:
1. 第一步：计算 13 - 9 = 4
   剩余数字：4, 4, 10

2. 第二步：计算 10 - 4 = 6
   剩余数字：4, 6

3. 第三步：计算 6 × 4 = 24 ✓
   达成目标！

验证：(10 - (13 - 9)) × 4 = (10 - 4) × 4 = 6 × 4 = 24 ✓
```

---

## 工作流程图（详细版）

```
┌─────────────────────────────────────────────────────────────┐
│ 第1阶段：初始化                                                │
└─────────────────────────────────────────────────────────────┘

用户: "用4、9、10、13得到24"
  ↓
Orchestrator:
  - 识别任务类型: math_reasoning
  - 选择策略: BFS, b=5, depth=3
  ↓
Decomposer:
  - 思维粒度: "single_equation"
  - 步骤: [选数字运算 → 结果再运算 → 得到24]
  - 约束: ["用所有数字", "+-×÷"]
  ↓
Explorer 初始化:
  - 创建 root 节点: {content: "初始: 4,9,10,13"}
  - frontier = [root]

┌─────────────────────────────────────────────────────────────┐
│ 第2阶段：搜索循环（Depth 0 → 1）                              │
└─────────────────────────────────────────────────────────────┘

Explorer: 扩展 root
  ↓
Generator: 生成5个候选
  → cand_1: "13-9=4, 剩余4,4,10"
  → cand_2: "10+4=14, 剩余9,13,14"
  → cand_3: "13×4=52, 剩余9,10,52"
  → cand_4: "10-4=6, 剩余6,9,13"
  → cand_5: "9+4=13, 剩余10,13,13"
  ↓
Evaluator: 评估5个候选
  → cand_1: 7.5分（有希望，4的倍数）
  → cand_2: 6.0分（14接近24的一半）
  → cand_3: 3.0分（52太大，难回到24）
  → cand_4: 7.0分（6是24的因子）
  → cand_5: 5.0分（两个13较难处理）
  ↓
Explorer: 选择 top-3 进入下一层
  → node_1 (cand_1): "13-9=4"
  → node_2 (cand_4): "10-4=6"
  → node_3 (cand_2): "10+4=14"
  frontier = [node_1, node_2, node_3]

┌─────────────────────────────────────────────────────────────┐
│ 第3阶段：搜索循环（Depth 1 → 2）                              │
└─────────────────────────────────────────────────────────────┘

Explorer: 扩展 node_1 (剩余4,4,10)
  ↓
Generator: 生成5个候选
  → "4+4=8, 剩余8,10"
  → "4×4=16, 剩余10,16"
  → "10-4=6, 剩余4,6"  ← 高分候选
  → "10+4=14, 剩余4,14"
  → "10÷4=2.5, 剩余4,2.5"
  ↓
Evaluator: 评估，选择 top-1
  → node_1_3: "10-4=6, 剩余4,6" (8.0分)

（同时扩展 node_2 和 node_3...）

┌─────────────────────────────────────────────────────────────┐
│ 第4阶段：搜索循环（Depth 2 → 3）                              │
└─────────────────────────────────────────────────────────────┘

Explorer: 扩展 node_1_3 (剩余4,6)
  ↓
Generator: 生成候选
  → "4+6=10"
  → "6-4=2"
  → "6×4=24" ✓✓✓  ← 找到答案！
  ↓
Evaluator:
  → "6×4=24": 10.0分（完美达成目标）
  ↓
Explorer: 标记为 terminal 节点，结束搜索
  best_path = [root, node_1, node_1_3, node_1_3_3]

┌─────────────────────────────────────────────────────────────┐
│ 第5阶段：合成答案                                              │
└─────────────────────────────────────────────────────────────┘

Synthesizer:
  输入: [root, node_1, node_1_3, node_1_3_3]
  ↓
  整合为:
    步骤1: 13-9=4
    步骤2: 10-4=6
    步骤3: 6×4=24
  ↓
  验证: (10-(13-9))×4 = 24 ✓
  ↓
Orchestrator: 返回用户
```

---

## 与传统方法对比

| 维度 | Chain-of-Thought (CoT) | ToT |
|-----|----------------------|-----|
| **推理路径** | 单条线性路径 | 树形多路径 |
| **错误恢复** | 无（一错到底） | 自动回溯 |
| **探索性** | 贪心选择 | 系统搜索 |
| **适用任务** | 简单推理 | 复杂规划、创意 |
| **成本** | 1次LLM调用 | k×d 次（但成功率高） |

**论文数据**：
- 游戏24：CoT 4%成功率 → ToT 74%成功率
- 创意写作：用户偏好 ToT vs CoT = 41:21
- 填字游戏：ToT 词汇准确率 60% vs CoT 15.6%

---

## 关键设计原则

### 1. 关注点分离
每个 Agent 只负责一件事：
- Decomposer 不做生成
- Generator 不做评估
- Evaluator 不做搜索

### 2. 统一协议
所有通信遵守 `protocol.md` 规范，确保互操作性

### 3. 可配置性
超参数（分支因子、深度、阈值）可根据任务调整

### 4. 透明性
每个决策（评分、剪枝）都有明确理由，便于调试

### 5. 可扩展性
新增任务类型只需：
- 在 Decomposer 添加分解策略
- 在 Generator 添加 Prompt 模板
- 在 Evaluator 添加评估维度

---

## 性能考虑

### 成本控制
- 浅层任务（depth≤3）：使用 BFS，成本可控
- 深层任务：使用 DFS + 早期剪枝
- 评估策略：用 Comparative Voting 代替 Independent Scoring

### 质量保证
- 分支因子不宜过小（<3），否则错过最优解
- 剪枝阈值不宜过高（>7），否则过早放弃
- 生成多样性：Independent Sampling 优于 Sequential Proposal

---

## 适用场景

### ✅ 推荐使用
- 需要多步推理的问题（数学、逻辑）
- 创意任务（写作、设计）
- 有明确目标的规划任务
- 约束满足问题（排班、配置）

### ❌ 不推荐使用
- 简单查询（"什么是...？"）
- 单步操作
- 对延迟敏感的实时应用
- 成本敏感的高频任务

---

## 未来改进方向

1. **自适应分支因子**：根据当前层的评分分布动态调整
2. **并行探索**：同时扩展多个节点，加速搜索
3. **学习剪枝策略**：从历史任务中学习何时应该剪枝
4. **混合搜索**：结合 BFS 和 DFS 的优点
5. **增量合成**：边搜索边生成部分答案

---

**架构版本**: 1.0
**基于论文**: [Tree of Thoughts (arxiv.org/html/2305.10601v2)](https://arxiv.org/html/2305.10601v2)
**最后更新**: 2025-10-28
